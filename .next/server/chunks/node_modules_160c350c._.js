module.exports = {

"[project]/node_modules/ms/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}}),
"[project]/node_modules/debug/src/common.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-route] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}}),
"[project]/node_modules/debug/src/node.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-route] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}}),
"[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}}),
"[project]/node_modules/debug/src/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/node.js [app-route] (ecmascript)");
}
}}),
"[project]/node_modules/has-flag/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}}),
"[project]/node_modules/supports-color/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}}),
"[project]/node_modules/follow-redirects/debug.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var debug;
module.exports = function() {
    if (!debug) {
        try {
            /* eslint global-require: off */ debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")("follow-redirects");
        } catch (error) {}
        if (typeof debug !== "function") {
            debug = function() {};
        }
    }
    debug.apply(null, arguments);
};
}}),
"[project]/node_modules/follow-redirects/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var URL = url.URL;
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var Writable = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Writable;
var assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
var debug = __turbopack_context__.r("[project]/node_modules/follow-redirects/debug.js [app-route] (ecmascript)");
// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = "undefined" !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
    }
})();
// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
    assert(new URL(""));
} catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
}
// URL fields to preserve in copy operations
var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
];
// Create handlers that pass events from native requests
var events = [
    "abort",
    "aborted",
    "connect",
    "error",
    "socket",
    "timeout"
];
var eventHandlers = Object.create(null);
events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
    };
});
// Error types with codes
var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;
// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
    // Initialize the request
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    // Attach a callback if passed
    if (responseCallback) {
        this.on("response", responseCallback);
    }
    // React to responses of native requests
    var self = this;
    this._onNativeResponse = function(response) {
        try {
            self._processResponse(response);
        } catch (cause) {
            self.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({
                cause: cause
            }));
        }
    };
    // Perform the first request
    this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
};
// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function(data, encoding, callback) {
    // Writing is not allowed if end has been called
    if (this._ending) {
        throw new WriteAfterEndError();
    }
    // Validate input and shift parameters if necessary
    if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Ignore empty buffers, since writing them doesn't invoke the callback
    // https://github.com/nodejs/node/issues/22066
    if (data.length === 0) {
        if (callback) {
            callback();
        }
        return;
    }
    // Only write when we don't exceed the maximum body length
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({
            data: data,
            encoding: encoding
        });
        this._currentRequest.write(data, encoding, callback);
    } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
    }
};
// Ends the current native request
RedirectableRequest.prototype.end = function(data, encoding, callback) {
    // Shift parameters if necessary
    if (isFunction(data)) {
        callback = data;
        data = encoding = null;
    } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Write data if needed and end
    if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
    } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
            self._ended = true;
            currentRequest.end(null, null, callback);
        });
        this._ending = true;
    }
};
// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
};
// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
};
// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self = this;
    // Destroys the socket on timeout
    function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
    }
    // Sets up a timer to trigger a timeout event
    function startTimer(socket) {
        if (self._timeout) {
            clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
            self.emit("timeout");
            clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
    }
    // Stops a timeout from triggering
    function clearTimer() {
        // Clear the timeout
        if (self._timeout) {
            clearTimeout(self._timeout);
            self._timeout = null;
        }
        // Clean up all attached listeners
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        self.removeListener("close", clearTimer);
        if (callback) {
            self.removeListener("timeout", callback);
        }
        if (!self.socket) {
            self._currentRequest.removeListener("socket", startTimer);
        }
    }
    // Attach callback if passed
    if (callback) {
        this.on("timeout", callback);
    }
    // Start the timer if or when the socket is opened
    if (this.socket) {
        startTimer(this.socket);
    } else {
        this._currentRequest.once("socket", startTimer);
    }
    // Clean up on events
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
};
// Proxy all other public ClientRequest methods
[
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
    };
});
// Proxy all public ClientRequest properties
[
    "aborted",
    "connection",
    "socket"
].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
            return this._currentRequest[property];
        }
    });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
    // Ensure headers are always present
    if (!options.headers) {
        options.headers = {};
    }
    // Since http.request treats host as an alias of hostname,
    // but the url module interprets host as hostname plus port,
    // eliminate the host property to avoid confusion.
    if (options.host) {
        // Use hostname if set, because it has precedence
        if (!options.hostname) {
            options.hostname = options.host;
        }
        delete options.host;
    }
    // Complete the URL object when necessary
    if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
            options.pathname = options.path;
        } else {
            options.pathname = options.path.substring(0, searchPos);
            options.search = options.path.substring(searchPos);
        }
    }
};
// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function() {
    // Load the native protocol
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
    }
    // If specified, use the agent corresponding to the protocol
    // (HTTP and HTTPS use different types of agents)
    if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
    }
    // Create the native request and set up its event handlers
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events){
        request.on(event, eventHandlers[event]);
    }
    // RFC7230§5.3.1: When making a request directly to an origin server, […]
    // a client MUST send only the absolute path […] as the request-target.
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path;
    // End a redirected request
    // (The first request must be ended explicitly with RedirectableRequest#end)
    if (this._isRedirect) {
        // Write the request entity and end
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
            // Only write if this request has not been redirected yet
            // istanbul ignore else
            if (request === self._currentRequest) {
                // Report any write errors
                // istanbul ignore if
                if (error) {
                    self.emit("error", error);
                } else if (i < buffers.length) {
                    var buffer = buffers[i++];
                    // istanbul ignore else
                    if (!request.finished) {
                        request.write(buffer.data, buffer.encoding, writeNext);
                    }
                } else if (self._ended) {
                    request.end();
                }
            }
        })();
    }
};
// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function(response) {
    // Store the redirected response
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
        this._redirects.push({
            url: this._currentUrl,
            headers: response.headers,
            statusCode: statusCode
        });
    }
    // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
    // that further action needs to be taken by the user agent in order to
    // fulfill the request. If a Location header field is provided,
    // the user agent MAY automatically redirect its request to the URI
    // referenced by the Location field value,
    // even if the specific status code is not understood.
    // If the response is not a redirect; return it as-is
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        // Clean up
        this._requestBodyBuffers = [];
        return;
    }
    // The response is a redirect, so abort the current request
    destroyRequest(this._currentRequest);
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();
    // RFC7231§6.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
    }
    // Store the request headers if applicable
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
        requestHeaders = Object.assign({
            // The Host header was set by nativeProtocol.request
            Host: response.req.getHeader("host")
        }, this._options.headers);
    }
    // RFC7231§6.4: Automatic redirection needs to done with
    // care for methods not known to be safe, […]
    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource […]
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) […]
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        // Drop a possible entity and headers related to it
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    // Drop the Host header, as the redirect might lead to a different host
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    // If the redirect is relative, carry over the host of the last request
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {
        host: currentHost
    }));
    // Create the redirected request
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    // Drop confidential headers when redirecting to a less secure protocol
    // or to a different domain that is not a superdomain
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    // Evaluate the beforeRedirect callback
    if (isFunction(beforeRedirect)) {
        var responseDetails = {
            headers: response.headers,
            statusCode: statusCode
        };
        var requestDetails = {
            url: currentUrl,
            method: method,
            headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
    }
    // Perform the redirected request
    this._performRequest();
};
// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
    // Default settings
    var exports = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
    };
    // Wrap each protocol
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
        // Executes a request, following redirects
        function request(input, options, callback) {
            // Parse parameters, ensuring that input is an object
            if (isURL(input)) {
                input = spreadUrlObject(input);
            } else if (isString(input)) {
                input = spreadUrlObject(parseUrl(input));
            } else {
                callback = options;
                options = validateUrl(input);
                input = {
                    protocol: protocol
                };
            }
            if (isFunction(options)) {
                callback = options;
                options = null;
            }
            // Set defaults
            options = Object.assign({
                maxRedirects: exports.maxRedirects,
                maxBodyLength: exports.maxBodyLength
            }, input, options);
            options.nativeProtocols = nativeProtocols;
            if (!isString(options.host) && !isString(options.hostname)) {
                options.hostname = "::1";
            }
            assert.equal(options.protocol, protocol, "protocol mismatch");
            debug("options", options);
            return new RedirectableRequest(options, callback);
        }
        // Executes a GET request, following redirects
        function get(input, options, callback) {
            var wrappedRequest = wrappedProtocol.request(input, options, callback);
            wrappedRequest.end();
            return wrappedRequest;
        }
        // Expose the properties on the wrapped protocol
        Object.defineProperties(wrappedProtocol, {
            request: {
                value: request,
                configurable: true,
                enumerable: true,
                writable: true
            },
            get: {
                value: get,
                configurable: true,
                enumerable: true,
                writable: true
            }
        });
    });
    return exports;
}
function noop() {}
function parseUrl(input) {
    var parsed;
    // istanbul ignore else
    if (useNativeURL) {
        parsed = new URL(input);
    } else {
        // Ensure the URL is valid and absolute
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
            throw new InvalidUrlError({
                input
            });
        }
    }
    return parsed;
}
function resolveUrl(relative, base) {
    // istanbul ignore next
    return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    return input;
}
function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields){
        spread[key] = urlObject[key];
    }
    // Fix IPv6 hostname
    if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
    }
    // Ensure port is a number
    if (spread.port !== "") {
        spread.port = Number(spread.port);
    }
    // Concatenate path
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
}
function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for(var header in headers){
        if (regex.test(header)) {
            lastValue = headers[header];
            delete headers[header];
        }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
    // Create constructor
    function CustomError(properties) {
        // istanbul ignore else
        if (isFunction(Error.captureStackTrace)) {
            Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    // Attach constructor and set default properties
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
        constructor: {
            value: CustomError,
            enumerable: false
        },
        name: {
            value: "Error [" + code + "]",
            enumerable: false
        }
    });
    return CustomError;
}
function destroyRequest(request, error) {
    for (var event of events){
        request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop);
    request.destroy(error);
}
function isSubdomain(subdomain, domain) {
    assert(isString(subdomain) && isString(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
    return typeof value === "function";
}
function isBuffer(value) {
    return typeof value === "object" && "length" in value;
}
function isURL(value) {
    return URL && value instanceof URL;
}
// Exports
module.exports = wrap({
    http: http,
    https: https
});
module.exports.wrap = wrap;
}}),
"[project]/node_modules/fast-fifo/fixed-size.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = class FixedFIFO {
    constructor(hwm){
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two');
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
    }
    clear() {
        this.top = this.btm = 0;
        this.next = null;
        this.buffer.fill(undefined);
    }
    push(data) {
        if (this.buffer[this.top] !== undefined) return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
    }
    shift() {
        const last = this.buffer[this.btm];
        if (last === undefined) return undefined;
        this.buffer[this.btm] = undefined;
        this.btm = this.btm + 1 & this.mask;
        return last;
    }
    peek() {
        return this.buffer[this.btm];
    }
    isEmpty() {
        return this.buffer[this.btm] === undefined;
    }
};
}}),
"[project]/node_modules/fast-fifo/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const FixedFIFO = __turbopack_context__.r("[project]/node_modules/fast-fifo/fixed-size.js [app-route] (ecmascript)");
module.exports = class FastFIFO {
    constructor(hwm){
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
        this.length = 0;
    }
    clear() {
        this.head = this.tail;
        this.head.clear();
        this.length = 0;
    }
    push(val) {
        this.length++;
        if (!this.head.push(val)) {
            const prev = this.head;
            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
            this.head.push(val);
        }
    }
    shift() {
        if (this.length !== 0) this.length--;
        const val = this.tail.shift();
        if (val === undefined && this.tail.next) {
            const next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            return this.tail.shift();
        }
        return val;
    }
    peek() {
        const val = this.tail.peek();
        if (val === undefined && this.tail.next) return this.tail.next.peek();
        return val;
    }
    isEmpty() {
        return this.length === 0;
    }
};
}}),
"[project]/node_modules/b4a/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function isBuffer(value) {
    return Buffer.isBuffer(value) || value instanceof Uint8Array;
}
function isEncoding(encoding) {
    return Buffer.isEncoding(encoding);
}
function alloc(size, fill, encoding) {
    return Buffer.alloc(size, fill, encoding);
}
function allocUnsafe(size) {
    return Buffer.allocUnsafe(size);
}
function allocUnsafeSlow(size) {
    return Buffer.allocUnsafeSlow(size);
}
function byteLength(string, encoding) {
    return Buffer.byteLength(string, encoding);
}
function compare(a, b) {
    return Buffer.compare(a, b);
}
function concat(buffers, totalLength) {
    return Buffer.concat(buffers, totalLength);
}
function copy(source, target, targetStart, start, end) {
    return toBuffer(source).copy(target, targetStart, start, end);
}
function equals(a, b) {
    return toBuffer(a).equals(b);
}
function fill(buffer, value, offset, end, encoding) {
    return toBuffer(buffer).fill(value, offset, end, encoding);
}
function from(value, encodingOrOffset, length) {
    return Buffer.from(value, encodingOrOffset, length);
}
function includes(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).includes(value, byteOffset, encoding);
}
function indexOf(buffer, value, byfeOffset, encoding) {
    return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
}
function lastIndexOf(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
}
function swap16(buffer) {
    return toBuffer(buffer).swap16();
}
function swap32(buffer) {
    return toBuffer(buffer).swap32();
}
function swap64(buffer) {
    return toBuffer(buffer).swap64();
}
function toBuffer(buffer) {
    if (Buffer.isBuffer(buffer)) return buffer;
    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}
function toString(buffer, encoding, start, end) {
    return toBuffer(buffer).toString(encoding, start, end);
}
function write(buffer, string, offset, length, encoding) {
    return toBuffer(buffer).write(string, offset, length, encoding);
}
function writeDoubleLE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleLE(value, offset);
}
function writeFloatLE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatLE(value, offset);
}
function writeUInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32LE(value, offset);
}
function writeInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32LE(value, offset);
}
function readDoubleLE(buffer, offset) {
    return toBuffer(buffer).readDoubleLE(offset);
}
function readFloatLE(buffer, offset) {
    return toBuffer(buffer).readFloatLE(offset);
}
function readUInt32LE(buffer, offset) {
    return toBuffer(buffer).readUInt32LE(offset);
}
function readInt32LE(buffer, offset) {
    return toBuffer(buffer).readInt32LE(offset);
}
function writeDoubleBE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleBE(value, offset);
}
function writeFloatBE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatBE(value, offset);
}
function writeUInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32BE(value, offset);
}
function writeInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32BE(value, offset);
}
function readDoubleBE(buffer, offset) {
    return toBuffer(buffer).readDoubleBE(offset);
}
function readFloatBE(buffer, offset) {
    return toBuffer(buffer).readFloatBE(offset);
}
function readUInt32BE(buffer, offset) {
    return toBuffer(buffer).readUInt32BE(offset);
}
function readInt32BE(buffer, offset) {
    return toBuffer(buffer).readInt32BE(offset);
}
module.exports = {
    isBuffer,
    isEncoding,
    alloc,
    allocUnsafe,
    allocUnsafeSlow,
    byteLength,
    compare,
    concat,
    copy,
    equals,
    fill,
    from,
    includes,
    indexOf,
    lastIndexOf,
    swap16,
    swap32,
    swap64,
    toBuffer,
    toString,
    write,
    writeDoubleLE,
    writeFloatLE,
    writeUInt32LE,
    writeInt32LE,
    readDoubleLE,
    readFloatLE,
    readUInt32LE,
    readInt32LE,
    writeDoubleBE,
    writeFloatBE,
    writeUInt32BE,
    writeInt32BE,
    readDoubleBE,
    readFloatBE,
    readUInt32BE,
    readInt32BE
};
}}),
"[project]/node_modules/text-decoder/lib/pass-through-decoder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const b4a = __turbopack_context__.r("[project]/node_modules/b4a/index.js [app-route] (ecmascript)");
module.exports = class PassThroughDecoder {
    constructor(encoding){
        this.encoding = encoding;
    }
    get remaining() {
        return 0;
    }
    decode(tail) {
        return b4a.toString(tail, this.encoding);
    }
    flush() {
        return '';
    }
};
}}),
"[project]/node_modules/text-decoder/lib/utf8-decoder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const b4a = __turbopack_context__.r("[project]/node_modules/b4a/index.js [app-route] (ecmascript)");
/**
 * https://encoding.spec.whatwg.org/#utf-8-decoder
 */ module.exports = class UTF8Decoder {
    constructor(){
        this.codePoint = 0;
        this.bytesSeen = 0;
        this.bytesNeeded = 0;
        this.lowerBoundary = 0x80;
        this.upperBoundary = 0xbf;
    }
    get remaining() {
        return this.bytesSeen;
    }
    decode(data) {
        // If we have a fast path, just sniff if the last part is a boundary
        if (this.bytesNeeded === 0) {
            let isBoundary = true;
            for(let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++){
                isBoundary = data[i] <= 0x7f;
            }
            if (isBoundary) return b4a.toString(data, 'utf8');
        }
        let result = '';
        for(let i = 0, n = data.byteLength; i < n; i++){
            const byte = data[i];
            if (this.bytesNeeded === 0) {
                if (byte <= 0x7f) {
                    result += String.fromCharCode(byte);
                } else {
                    this.bytesSeen = 1;
                    if (byte >= 0xc2 && byte <= 0xdf) {
                        this.bytesNeeded = 2;
                        this.codePoint = byte & 0x1f;
                    } else if (byte >= 0xe0 && byte <= 0xef) {
                        if (byte === 0xe0) this.lowerBoundary = 0xa0;
                        else if (byte === 0xed) this.upperBoundary = 0x9f;
                        this.bytesNeeded = 3;
                        this.codePoint = byte & 0xf;
                    } else if (byte >= 0xf0 && byte <= 0xf4) {
                        if (byte === 0xf0) this.lowerBoundary = 0x90;
                        if (byte === 0xf4) this.upperBoundary = 0x8f;
                        this.bytesNeeded = 4;
                        this.codePoint = byte & 0x7;
                    } else {
                        result += '\ufffd';
                    }
                }
                continue;
            }
            if (byte < this.lowerBoundary || byte > this.upperBoundary) {
                this.codePoint = 0;
                this.bytesNeeded = 0;
                this.bytesSeen = 0;
                this.lowerBoundary = 0x80;
                this.upperBoundary = 0xbf;
                result += '\ufffd';
                continue;
            }
            this.lowerBoundary = 0x80;
            this.upperBoundary = 0xbf;
            this.codePoint = this.codePoint << 6 | byte & 0x3f;
            this.bytesSeen++;
            if (this.bytesSeen !== this.bytesNeeded) continue;
            result += String.fromCodePoint(this.codePoint);
            this.codePoint = 0;
            this.bytesNeeded = 0;
            this.bytesSeen = 0;
        }
        return result;
    }
    flush() {
        const result = this.bytesNeeded > 0 ? '\ufffd' : '';
        this.codePoint = 0;
        this.bytesNeeded = 0;
        this.bytesSeen = 0;
        this.lowerBoundary = 0x80;
        this.upperBoundary = 0xbf;
        return result;
    }
};
}}),
"[project]/node_modules/text-decoder/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const PassThroughDecoder = __turbopack_context__.r("[project]/node_modules/text-decoder/lib/pass-through-decoder.js [app-route] (ecmascript)");
const UTF8Decoder = __turbopack_context__.r("[project]/node_modules/text-decoder/lib/utf8-decoder.js [app-route] (ecmascript)");
module.exports = class TextDecoder {
    constructor(encoding = 'utf8'){
        this.encoding = normalizeEncoding(encoding);
        switch(this.encoding){
            case 'utf8':
                this.decoder = new UTF8Decoder();
                break;
            case 'utf16le':
            case 'base64':
                throw new Error('Unsupported encoding: ' + this.encoding);
            default:
                this.decoder = new PassThroughDecoder(this.encoding);
        }
    }
    get remaining() {
        return this.decoder.remaining;
    }
    push(data) {
        if (typeof data === 'string') return data;
        return this.decoder.decode(data);
    }
    // For Node.js compatibility
    write(data) {
        return this.push(data);
    }
    end(data) {
        let result = '';
        if (data) result = this.push(data);
        result += this.decoder.flush();
        return result;
    }
};
function normalizeEncoding(encoding) {
    encoding = encoding.toLowerCase();
    switch(encoding){
        case 'utf8':
        case 'utf-8':
            return 'utf8';
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return 'utf16le';
        case 'latin1':
        case 'binary':
            return 'latin1';
        case 'base64':
        case 'ascii':
        case 'hex':
            return encoding;
        default:
            throw new Error('Unknown encoding: ' + encoding);
    }
}
;
}}),
"[project]/node_modules/streamx/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const { EventEmitter } = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const STREAM_DESTROYED = new Error('Stream was destroyed');
const PREMATURE_CLOSE = new Error('Premature close');
const FIFO = __turbopack_context__.r("[project]/node_modules/fast-fifo/index.js [app-route] (ecmascript)");
const TextDecoder = __turbopack_context__.r("[project]/node_modules/text-decoder/index.js [app-route] (ecmascript)");
// if we do a future major, expect queue microtask to be there always, for now a bit defensive
const qmt = typeof queueMicrotask === 'undefined' ? (fn)=>global.process.nextTick(fn) : queueMicrotask;
/* eslint-disable no-multi-spaces */ // 29 bits used total (4 from shared, 14 from read, and 11 from write)
const MAX = (1 << 29) - 1;
// Shared state
const OPENING = 0b0001;
const PREDESTROYING = 0b0010;
const DESTROYING = 0b0100;
const DESTROYED = 0b1000;
const NOT_OPENING = MAX ^ OPENING;
const NOT_PREDESTROYING = MAX ^ PREDESTROYING;
// Read state (4 bit offset from shared state)
const READ_ACTIVE = 0b00000000000001 << 4;
const READ_UPDATING = 0b00000000000010 << 4;
const READ_PRIMARY = 0b00000000000100 << 4;
const READ_QUEUED = 0b00000000001000 << 4;
const READ_RESUMED = 0b00000000010000 << 4;
const READ_PIPE_DRAINED = 0b00000000100000 << 4;
const READ_ENDING = 0b00000001000000 << 4;
const READ_EMIT_DATA = 0b00000010000000 << 4;
const READ_EMIT_READABLE = 0b00000100000000 << 4;
const READ_EMITTED_READABLE = 0b00001000000000 << 4;
const READ_DONE = 0b00010000000000 << 4;
const READ_NEXT_TICK = 0b00100000000000 << 4;
const READ_NEEDS_PUSH = 0b01000000000000 << 4;
const READ_READ_AHEAD = 0b10000000000000 << 4;
// Combined read state
const READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
const READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
const READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
const READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
const READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
const READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
const READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
const READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
const READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
const READ_PAUSED = MAX ^ READ_RESUMED;
const READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
const READ_NOT_ENDING = MAX ^ READ_ENDING;
const READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
const READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
const READ_NOT_UPDATING = MAX ^ READ_UPDATING;
const READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
const READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)
const WRITE_ACTIVE = 0b00000000001 << 18;
const WRITE_UPDATING = 0b00000000010 << 18;
const WRITE_PRIMARY = 0b00000000100 << 18;
const WRITE_QUEUED = 0b00000001000 << 18;
const WRITE_UNDRAINED = 0b00000010000 << 18;
const WRITE_DONE = 0b00000100000 << 18;
const WRITE_EMIT_DRAIN = 0b00001000000 << 18;
const WRITE_NEXT_TICK = 0b00010000000 << 18;
const WRITE_WRITING = 0b00100000000 << 18;
const WRITE_FINISHING = 0b01000000000 << 18;
const WRITE_CORKED = 0b10000000000 << 18;
const WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
const WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
const WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
const WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
const WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
const WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
const WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
const WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
// Combined shared state
const ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
const NOT_ACTIVE = MAX ^ ACTIVE;
const DONE = READ_DONE | WRITE_DONE;
const DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
const OPEN_STATUS = DESTROY_STATUS | OPENING;
const AUTO_DESTROY = DESTROY_STATUS | DONE;
const NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
const ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
const TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
const IS_OPENING = OPEN_STATUS | TICKING;
// Combined shared state and read state
const READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
const READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
const READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
const READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
const SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
const READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
const READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
const READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
// Combined write state
const WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
const WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
const WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
const WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
const WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
const WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
const WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
const WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
const WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
const WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
const WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;
const asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');
class WritableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}){
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark;
        this.buffered = 0;
        this.error = null;
        this.pipeline = null;
        this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr
        ;
        this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
        this.map = mapWritable || map;
        this.afterWrite = afterWrite.bind(this);
        this.afterUpdateNextTick = updateWriteNT.bind(this);
    }
    get ended() {
        return (this.stream._duplexState & WRITE_DONE) !== 0;
    }
    push(data) {
        if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false;
        if (this.map !== null) data = this.map(data);
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        if (this.buffered < this.highWaterMark) {
            this.stream._duplexState |= WRITE_QUEUED;
            return true;
        }
        this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
        return false;
    }
    shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;
        return data;
    }
    end(data) {
        if (typeof data === 'function') this.stream.once('finish', data);
        else if (data !== undefined && data !== null) this.push(data);
        this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
    }
    autoBatch(data, cb) {
        const buffer = [];
        const stream = this.stream;
        buffer.push(data);
        while((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE){
            buffer.push(stream._writableState.shift());
        }
        if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);
        stream._writev(buffer, cb);
    }
    update() {
        const stream = this.stream;
        stream._duplexState |= WRITE_UPDATING;
        do {
            while((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED){
                const data = this.shift();
                stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
                stream._write(data, this.afterWrite);
            }
            if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
        }while (this.continueUpdate() === true)
        stream._duplexState &= WRITE_NOT_UPDATING;
    }
    updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
            stream._duplexState = stream._duplexState | WRITE_ACTIVE;
            stream._final(afterFinal.bind(this));
            return;
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
            if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
                stream._duplexState |= ACTIVE;
                stream._destroy(afterDestroy.bind(this));
            }
            return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
            stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
            stream._open(afterOpen.bind(this));
        }
    }
    continueUpdate() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        return true;
    }
    updateCallback() {
        if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();
        else this.updateNextTick();
    }
    updateNextTick() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;
        this.stream._duplexState |= WRITE_NEXT_TICK;
        if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick);
    }
}
class ReadableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}){
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
        this.buffered = 0;
        this.readAhead = highWaterMark > 0;
        this.error = null;
        this.pipeline = null;
        this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
        this.map = mapReadable || map;
        this.pipeTo = null;
        this.afterRead = afterRead.bind(this);
        this.afterUpdateNextTick = updateReadNT.bind(this);
    }
    get ended() {
        return (this.stream._duplexState & READ_DONE) !== 0;
    }
    pipe(pipeTo, cb) {
        if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');
        if (typeof cb !== 'function') cb = null;
        this.stream._duplexState |= READ_PIPE_DRAINED;
        this.pipeTo = pipeTo;
        this.pipeline = new Pipeline(this.stream, pipeTo, cb);
        if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes
        ;
        if (isStreamx(pipeTo)) {
            pipeTo._writableState.pipeline = this.pipeline;
            if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes
            ;
            pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself
            ;
        } else {
            const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
            const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg
            ;
            pipeTo.on('error', onerror);
            pipeTo.on('close', onclose);
            pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));
        }
        pipeTo.on('drain', afterDrain.bind(this));
        this.stream.emit('piping', pipeTo);
        pipeTo.emit('pipe', this.stream);
    }
    push(data) {
        const stream = this.stream;
        if (data === null) {
            this.highWaterMark = 0;
            stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
            return false;
        }
        if (this.map !== null) {
            data = this.map(data);
            if (data === null) {
                stream._duplexState &= READ_PUSHED;
                return this.buffered < this.highWaterMark;
            }
        }
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
        return this.buffered < this.highWaterMark;
    }
    shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
        return data;
    }
    unshift(data) {
        const pending = [
            this.map !== null ? this.map(data) : data
        ];
        while(this.buffered > 0)pending.push(this.shift());
        for(let i = 0; i < pending.length - 1; i++){
            const data = pending[i];
            this.buffered += this.byteLength(data);
            this.queue.push(data);
        }
        this.push(pending[pending.length - 1]);
    }
    read() {
        const stream = this.stream;
        if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
            const data = this.shift();
            if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
            if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
            return data;
        }
        if (this.readAhead === false) {
            stream._duplexState |= READ_READ_AHEAD;
            this.updateNextTick();
        }
        return null;
    }
    drain() {
        const stream = this.stream;
        while((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0){
            const data = this.shift();
            if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
            if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
        }
    }
    update() {
        const stream = this.stream;
        stream._duplexState |= READ_UPDATING;
        do {
            this.drain();
            while(this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD){
                stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
                stream._read(this.afterRead);
                this.drain();
            }
            if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
                stream._duplexState |= READ_EMITTED_READABLE;
                stream.emit('readable');
            }
            if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
        }while (this.continueUpdate() === true)
        stream._duplexState &= READ_NOT_UPDATING;
    }
    updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
            stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
            stream.emit('end');
            if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
            if (this.pipeTo !== null) this.pipeTo.end();
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
            if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
                stream._duplexState |= ACTIVE;
                stream._destroy(afterDestroy.bind(this));
            }
            return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
            stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
            stream._open(afterOpen.bind(this));
        }
    }
    continueUpdate() {
        if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        return true;
    }
    updateCallback() {
        if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();
        else this.updateNextTick();
    }
    updateNextTickIfOpen() {
        if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);
    }
    updateNextTick() {
        if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);
    }
}
class TransformState {
    constructor(stream){
        this.data = null;
        this.afterTransform = afterTransform.bind(stream);
        this.afterFinal = null;
    }
}
class Pipeline {
    constructor(src, dst, cb){
        this.from = src;
        this.to = dst;
        this.afterPipe = cb;
        this.error = null;
        this.pipeToFinished = false;
    }
    finished() {
        this.pipeToFinished = true;
    }
    done(stream, err) {
        if (err) this.error = err;
        if (stream === this.to) {
            this.to = null;
            if (this.from !== null) {
                if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
                    this.from.destroy(this.error || new Error('Writable stream closed prematurely'));
                }
                return;
            }
        }
        if (stream === this.from) {
            this.from = null;
            if (this.to !== null) {
                if ((stream._duplexState & READ_DONE) === 0) {
                    this.to.destroy(this.error || new Error('Readable stream closed before ending'));
                }
                return;
            }
        }
        if (this.afterPipe !== null) this.afterPipe(this.error);
        this.to = this.from = this.afterPipe = null;
    }
}
function afterDrain() {
    this.stream._duplexState |= READ_PIPE_DRAINED;
    this.updateCallback();
}
function afterFinal(err) {
    const stream = this.stream;
    if (err) stream.destroy(err);
    if ((stream._duplexState & DESTROY_STATUS) === 0) {
        stream._duplexState |= WRITE_DONE;
        stream.emit('finish');
    }
    if ((stream._duplexState & AUTO_DESTROY) === DONE) {
        stream._duplexState |= DESTROYING;
    }
    stream._duplexState &= WRITE_NOT_FINISHING;
    // no need to wait the extra tick here, so we short circuit that
    if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();
    else this.updateNextTick();
}
function afterDestroy(err) {
    const stream = this.stream;
    if (!err && this.error !== STREAM_DESTROYED) err = this.error;
    if (err) stream.emit('error', err);
    stream._duplexState |= DESTROYED;
    stream.emit('close');
    const rs = stream._readableState;
    const ws = stream._writableState;
    if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);
    if (ws !== null) {
        while(ws.drains !== null && ws.drains.length > 0)ws.drains.shift().resolve(false);
        if (ws.pipeline !== null) ws.pipeline.done(stream, err);
    }
}
function afterWrite(err) {
    const stream = this.stream;
    if (err) stream.destroy(err);
    stream._duplexState &= WRITE_NOT_ACTIVE;
    if (this.drains !== null) tickDrains(this.drains);
    if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
        stream._duplexState &= WRITE_DRAINED;
        if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
            stream.emit('drain');
        }
    }
    this.updateCallback();
}
function afterRead(err) {
    if (err) this.stream.destroy(err);
    this.stream._duplexState &= READ_NOT_ACTIVE;
    if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;
    this.updateCallback();
}
function updateReadNT() {
    if ((this.stream._duplexState & READ_UPDATING) === 0) {
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        this.update();
    }
}
function updateWriteNT() {
    if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        this.update();
    }
}
function tickDrains(drains) {
    for(let i = 0; i < drains.length; i++){
        // drains.writes are monotonic, so if one is 0 its always the first one
        if (--drains[i].writes === 0) {
            drains.shift().resolve(true);
            i--;
        }
    }
}
function afterOpen(err) {
    const stream = this.stream;
    if (err) stream.destroy(err);
    if ((stream._duplexState & DESTROYING) === 0) {
        if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;
        if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;
        stream.emit('open');
    }
    stream._duplexState &= NOT_ACTIVE;
    if (stream._writableState !== null) {
        stream._writableState.updateCallback();
    }
    if (stream._readableState !== null) {
        stream._readableState.updateCallback();
    }
}
function afterTransform(err, data) {
    if (data !== undefined && data !== null) this.push(data);
    this._writableState.afterWrite(err);
}
function newListener(name) {
    if (this._readableState !== null) {
        if (name === 'data') {
            this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
            this._readableState.updateNextTick();
        }
        if (name === 'readable') {
            this._duplexState |= READ_EMIT_READABLE;
            this._readableState.updateNextTick();
        }
    }
    if (this._writableState !== null) {
        if (name === 'drain') {
            this._duplexState |= WRITE_EMIT_DRAIN;
            this._writableState.updateNextTick();
        }
    }
}
class Stream extends EventEmitter {
    constructor(opts){
        super();
        this._duplexState = 0;
        this._readableState = null;
        this._writableState = null;
        if (opts) {
            if (opts.open) this._open = opts.open;
            if (opts.destroy) this._destroy = opts.destroy;
            if (opts.predestroy) this._predestroy = opts.predestroy;
            if (opts.signal) {
                opts.signal.addEventListener('abort', abort.bind(this));
            }
        }
        this.on('newListener', newListener);
    }
    _open(cb) {
        cb(null);
    }
    _destroy(cb) {
        cb(null);
    }
    _predestroy() {
    // does nothing
    }
    get readable() {
        return this._readableState !== null ? true : undefined;
    }
    get writable() {
        return this._writableState !== null ? true : undefined;
    }
    get destroyed() {
        return (this._duplexState & DESTROYED) !== 0;
    }
    get destroying() {
        return (this._duplexState & DESTROY_STATUS) !== 0;
    }
    destroy(err) {
        if ((this._duplexState & DESTROY_STATUS) === 0) {
            if (!err) err = STREAM_DESTROYED;
            this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
            if (this._readableState !== null) {
                this._readableState.highWaterMark = 0;
                this._readableState.error = err;
            }
            if (this._writableState !== null) {
                this._writableState.highWaterMark = 0;
                this._writableState.error = err;
            }
            this._duplexState |= PREDESTROYING;
            this._predestroy();
            this._duplexState &= NOT_PREDESTROYING;
            if (this._readableState !== null) this._readableState.updateNextTick();
            if (this._writableState !== null) this._writableState.updateNextTick();
        }
    }
}
class Readable extends Stream {
    constructor(opts){
        super(opts);
        this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
        this._readableState = new ReadableState(this, opts);
        if (opts) {
            if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;
            if (opts.read) this._read = opts.read;
            if (opts.eagerOpen) this._readableState.updateNextTick();
            if (opts.encoding) this.setEncoding(opts.encoding);
        }
    }
    setEncoding(encoding) {
        const dec = new TextDecoder(encoding);
        const map = this._readableState.map || echo;
        this._readableState.map = mapOrSkip;
        return this;
        "TURBOPACK unreachable";
        function mapOrSkip(data) {
            const next = dec.push(data);
            return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
        }
    }
    _read(cb) {
        cb(null);
    }
    pipe(dest, cb) {
        this._readableState.updateNextTick();
        this._readableState.pipe(dest, cb);
        return dest;
    }
    read() {
        this._readableState.updateNextTick();
        return this._readableState.read();
    }
    push(data) {
        this._readableState.updateNextTickIfOpen();
        return this._readableState.push(data);
    }
    unshift(data) {
        this._readableState.updateNextTickIfOpen();
        return this._readableState.unshift(data);
    }
    resume() {
        this._duplexState |= READ_RESUMED_READ_AHEAD;
        this._readableState.updateNextTick();
        return this;
    }
    pause() {
        this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
        return this;
    }
    static _fromAsyncIterator(ite, opts) {
        let destroy;
        const rs = new Readable({
            ...opts,
            read (cb) {
                ite.next().then(push).then(cb.bind(null, null)).catch(cb);
            },
            predestroy () {
                destroy = ite.return();
            },
            destroy (cb) {
                if (!destroy) return cb(null);
                destroy.then(cb.bind(null, null)).catch(cb);
            }
        });
        return rs;
        "TURBOPACK unreachable";
        function push(data) {
            if (data.done) rs.push(null);
            else rs.push(data.value);
        }
    }
    static from(data, opts) {
        if (isReadStreamx(data)) return data;
        if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);
        if (!Array.isArray(data)) data = data === undefined ? [] : [
            data
        ];
        let i = 0;
        return new Readable({
            ...opts,
            read (cb) {
                this.push(i === data.length ? null : data[i++]);
                cb(null);
            }
        });
    }
    static isBackpressured(rs) {
        return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
    }
    static isPaused(rs) {
        return (rs._duplexState & READ_RESUMED) === 0;
    }
    [asyncIterator]() {
        const stream = this;
        let error = null;
        let promiseResolve = null;
        let promiseReject = null;
        this.on('error', (err)=>{
            error = err;
        });
        this.on('readable', onreadable);
        this.on('close', onclose);
        return {
            [asyncIterator] () {
                return this;
            },
            next () {
                return new Promise(function(resolve, reject) {
                    promiseResolve = resolve;
                    promiseReject = reject;
                    const data = stream.read();
                    if (data !== null) ondata(data);
                    else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);
                });
            },
            return () {
                return destroy(null);
            },
            throw (err) {
                return destroy(err);
            }
        };
        "TURBOPACK unreachable";
        function onreadable() {
            if (promiseResolve !== null) ondata(stream.read());
        }
        function onclose() {
            if (promiseResolve !== null) ondata(null);
        }
        function ondata(data) {
            if (promiseReject === null) return;
            if (error) promiseReject(error);
            else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);
            else promiseResolve({
                value: data,
                done: data === null
            });
            promiseReject = promiseResolve = null;
        }
        function destroy(err) {
            stream.destroy(err);
            return new Promise((resolve, reject)=>{
                if (stream._duplexState & DESTROYED) return resolve({
                    value: undefined,
                    done: true
                });
                stream.once('close', function() {
                    if (err) reject(err);
                    else resolve({
                        value: undefined,
                        done: true
                    });
                });
            });
        }
    }
}
class Writable extends Stream {
    constructor(opts){
        super(opts);
        this._duplexState |= OPENING | READ_DONE;
        this._writableState = new WritableState(this, opts);
        if (opts) {
            if (opts.writev) this._writev = opts.writev;
            if (opts.write) this._write = opts.write;
            if (opts.final) this._final = opts.final;
            if (opts.eagerOpen) this._writableState.updateNextTick();
        }
    }
    cork() {
        this._duplexState |= WRITE_CORKED;
    }
    uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
        cb(null);
    }
    _write(data, cb) {
        this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
        cb(null);
    }
    static isBackpressured(ws) {
        return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
    }
    static drained(ws) {
        if (ws.destroyed) return Promise.resolve(false);
        const state = ws._writableState;
        const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
        const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
        if (writes === 0) return Promise.resolve(true);
        if (state.drains === null) state.drains = [];
        return new Promise((resolve)=>{
            state.drains.push({
                writes,
                resolve
            });
        });
    }
    write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
    }
    end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
    }
}
class Duplex extends Readable {
    constructor(opts){
        super(opts);
        this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
        this._writableState = new WritableState(this, opts);
        if (opts) {
            if (opts.writev) this._writev = opts.writev;
            if (opts.write) this._write = opts.write;
            if (opts.final) this._final = opts.final;
        }
    }
    cork() {
        this._duplexState |= WRITE_CORKED;
    }
    uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
        cb(null);
    }
    _write(data, cb) {
        this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
        cb(null);
    }
    write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
    }
    end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
    }
}
class Transform extends Duplex {
    constructor(opts){
        super(opts);
        this._transformState = new TransformState(this);
        if (opts) {
            if (opts.transform) this._transform = opts.transform;
            if (opts.flush) this._flush = opts.flush;
        }
    }
    _write(data, cb) {
        if (this._readableState.buffered >= this._readableState.highWaterMark) {
            this._transformState.data = data;
        } else {
            this._transform(data, this._transformState.afterTransform);
        }
    }
    _read(cb) {
        if (this._transformState.data !== null) {
            const data = this._transformState.data;
            this._transformState.data = null;
            cb(null);
            this._transform(data, this._transformState.afterTransform);
        } else {
            cb(null);
        }
    }
    destroy(err) {
        super.destroy(err);
        if (this._transformState.data !== null) {
            this._transformState.data = null;
            this._transformState.afterTransform();
        }
    }
    _transform(data, cb) {
        cb(null, data);
    }
    _flush(cb) {
        cb(null);
    }
    _final(cb) {
        this._transformState.afterFinal = cb;
        this._flush(transformAfterFlush.bind(this));
    }
}
class PassThrough extends Transform {
}
function transformAfterFlush(err, data) {
    const cb = this._transformState.afterFinal;
    if (err) return cb(err);
    if (data !== null && data !== undefined) this.push(data);
    this.push(null);
    cb(null);
}
function pipelinePromise(...streams) {
    return new Promise((resolve, reject)=>{
        return pipeline(...streams, (err)=>{
            if (err) return reject(err);
            resolve();
        });
    });
}
function pipeline(stream, ...streams) {
    const all = Array.isArray(stream) ? [
        ...stream,
        ...streams
    ] : [
        stream,
        ...streams
    ];
    const done = all.length && typeof all[all.length - 1] === 'function' ? all.pop() : null;
    if (all.length < 2) throw new Error('Pipeline requires at least 2 streams');
    let src = all[0];
    let dest = null;
    let error = null;
    for(let i = 1; i < all.length; i++){
        dest = all[i];
        if (isStreamx(src)) {
            src.pipe(dest, onerror);
        } else {
            errorHandle(src, true, i > 1, onerror);
            src.pipe(dest);
        }
        src = dest;
    }
    if (done) {
        let fin = false;
        const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
        dest.on('error', (err)=>{
            if (error === null) error = err;
        });
        dest.on('finish', ()=>{
            fin = true;
            if (!autoDestroy) done(error);
        });
        if (autoDestroy) {
            dest.on('close', ()=>done(error || (fin ? null : PREMATURE_CLOSE)));
        }
    }
    return dest;
    "TURBOPACK unreachable";
    function errorHandle(s, rd, wr, onerror) {
        s.on('error', onerror);
        s.on('close', onclose);
        function onclose() {
            if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE);
            if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE);
        }
    }
    function onerror(err) {
        if (!err || error) return;
        error = err;
        for (const s of all){
            s.destroy(err);
        }
    }
}
function echo(s) {
    return s;
}
function isStream(stream) {
    return !!stream._readableState || !!stream._writableState;
}
function isStreamx(stream) {
    return typeof stream._duplexState === 'number' && isStream(stream);
}
function isEnded(stream) {
    return !!stream._readableState && stream._readableState.ended;
}
function isFinished(stream) {
    return !!stream._writableState && stream._writableState.ended;
}
function getStreamError(stream, opts = {}) {
    const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
    // avoid implicit errors by default
    return !opts.all && err === STREAM_DESTROYED ? null : err;
}
function isReadStreamx(stream) {
    return isStreamx(stream) && stream.readable;
}
function isDisturbed(stream) {
    return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;
}
function isTypedArray(data) {
    return typeof data === 'object' && data !== null && typeof data.byteLength === 'number';
}
function defaultByteLength(data) {
    return isTypedArray(data) ? data.byteLength : 1024;
}
function noop() {}
function abort() {
    this.destroy(new Error('Stream aborted.'));
}
function isWritev(s) {
    return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
}
module.exports = {
    pipeline,
    pipelinePromise,
    isStream,
    isStreamx,
    isEnded,
    isFinished,
    isDisturbed,
    getStreamError,
    Stream,
    Writable,
    Readable,
    Duplex,
    Transform,
    // Export PassThrough for compatibility with Node.js core's stream module
    PassThrough
};
}}),
"[project]/node_modules/tar-stream/headers.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const b4a = __turbopack_context__.r("[project]/node_modules/b4a/index.js [app-route] (ecmascript)");
const ZEROS = '0000000000000000000';
const SEVENS = '7777777777777777777';
const ZERO_OFFSET = '0'.charCodeAt(0);
const USTAR_MAGIC = b4a.from([
    0x75,
    0x73,
    0x74,
    0x61,
    0x72,
    0x00
]) // ustar\x00
;
const USTAR_VER = b4a.from([
    ZERO_OFFSET,
    ZERO_OFFSET
]);
const GNU_MAGIC = b4a.from([
    0x75,
    0x73,
    0x74,
    0x61,
    0x72,
    0x20
]) // ustar\x20
;
const GNU_VER = b4a.from([
    0x20,
    0x00
]);
const MASK = 0o7777;
const MAGIC_OFFSET = 257;
const VERSION_OFFSET = 263;
exports.decodeLongPath = function decodeLongPath(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
};
exports.encodePax = function encodePax(opts) {
    let result = '';
    if (opts.name) result += addLength(' path=' + opts.name + '\n');
    if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n');
    const pax = opts.pax;
    if (pax) {
        for(const key in pax){
            result += addLength(' ' + key + '=' + pax[key] + '\n');
        }
    }
    return b4a.from(result);
};
exports.decodePax = function decodePax(buf) {
    const result = {};
    while(buf.length){
        let i = 0;
        while(i < buf.length && buf[i] !== 32)i++;
        const len = parseInt(b4a.toString(buf.subarray(0, i)), 10);
        if (!len) return result;
        const b = b4a.toString(buf.subarray(i + 1, len - 1));
        const keyIndex = b.indexOf('=');
        if (keyIndex === -1) return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.subarray(len);
    }
    return result;
};
exports.encode = function encode(opts) {
    const buf = b4a.alloc(512);
    let name = opts.name;
    let prefix = '';
    if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/';
    if (b4a.byteLength(name) !== name.length) return null // utf-8
    ;
    while(b4a.byteLength(name) > 100){
        const i = name.indexOf('/');
        if (i === -1) return null;
        prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
    }
    if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155) return null;
    if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null;
    b4a.write(buf, name);
    b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100);
    b4a.write(buf, encodeOct(opts.uid, 6), 108);
    b4a.write(buf, encodeOct(opts.gid, 6), 116);
    encodeSize(opts.size, buf, 124);
    b4a.write(buf, encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname) b4a.write(buf, opts.linkname, 157);
    b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
    b4a.copy(USTAR_VER, buf, VERSION_OFFSET);
    if (opts.uname) b4a.write(buf, opts.uname, 265);
    if (opts.gname) b4a.write(buf, opts.gname, 297);
    b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
    b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337);
    if (prefix) b4a.write(buf, prefix, 345);
    b4a.write(buf, encodeOct(cksum(buf), 6), 148);
    return buf;
};
exports.decode = function decode(buf, filenameEncoding, allowUnknownFormat) {
    let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    let name = decodeStr(buf, 0, 100, filenameEncoding);
    const mode = decodeOct(buf, 100, 8);
    const uid = decodeOct(buf, 108, 8);
    const gid = decodeOct(buf, 116, 8);
    const size = decodeOct(buf, 124, 12);
    const mtime = decodeOct(buf, 136, 12);
    const type = toType(typeflag);
    const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    const uname = decodeStr(buf, 265, 32);
    const gname = decodeStr(buf, 297, 32);
    const devmajor = decodeOct(buf, 329, 8);
    const devminor = decodeOct(buf, 337, 8);
    const c = cksum(buf);
    // checksum is still initial value if header was null.
    if (c === 8 * 32) return null;
    // valid checksum
    if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?');
    if (isUSTAR(buf)) {
        // ustar (posix) format.
        // prepend prefix, if present.
        if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name;
    } else if (isGNU(buf)) {
    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and
    // multi-volume tarballs.
    } else {
        if (!allowUnknownFormat) {
            throw new Error('Invalid tar header: unknown format.');
        }
    }
    // to support old tar versions that use trailing / to indicate dirs
    if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5;
    return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1000 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor,
        pax: null
    };
};
function isUSTAR(buf) {
    return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
}
function isGNU(buf) {
    return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
}
function clamp(index, len, defaultValue) {
    if (typeof index !== 'number') return defaultValue;
    index = ~~index // Coerce to integer.
    ;
    if (index >= len) return len;
    if (index >= 0) return index;
    index += len;
    if (index >= 0) return index;
    return 0;
}
function toType(flag) {
    switch(flag){
        case 0:
            return 'file';
        case 1:
            return 'link';
        case 2:
            return 'symlink';
        case 3:
            return 'character-device';
        case 4:
            return 'block-device';
        case 5:
            return 'directory';
        case 6:
            return 'fifo';
        case 7:
            return 'contiguous-file';
        case 72:
            return 'pax-header';
        case 55:
            return 'pax-global-header';
        case 27:
            return 'gnu-long-link-path';
        case 28:
        case 30:
            return 'gnu-long-path';
    }
    return null;
}
function toTypeflag(flag) {
    switch(flag){
        case 'file':
            return 0;
        case 'link':
            return 1;
        case 'symlink':
            return 2;
        case 'character-device':
            return 3;
        case 'block-device':
            return 4;
        case 'directory':
            return 5;
        case 'fifo':
            return 6;
        case 'contiguous-file':
            return 7;
        case 'pax-header':
            return 72;
    }
    return 0;
}
function indexOf(block, num, offset, end) {
    for(; offset < end; offset++){
        if (block[offset] === num) return offset;
    }
    return end;
}
function cksum(block) {
    let sum = 8 * 32;
    for(let i = 0; i < 148; i++)sum += block[i];
    for(let j = 156; j < 512; j++)sum += block[j];
    return sum;
}
function encodeOct(val, n) {
    val = val.toString(8);
    if (val.length > n) return SEVENS.slice(0, n) + ' ';
    return ZEROS.slice(0, n - val.length) + val + ' ';
}
function encodeSizeBin(num, buf, off) {
    buf[off] = 0x80;
    for(let i = 11; i > 0; i--){
        buf[off + i] = num & 0xff;
        num = Math.floor(num / 0x100);
    }
}
function encodeSize(num, buf, off) {
    if (num.toString(8).length > 11) {
        encodeSizeBin(num, buf, off);
    } else {
        b4a.write(buf, encodeOct(num, 11), off);
    }
}
/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */ function parse256(buf) {
    // first byte MUST be either 80 or FF
    // 80 for positive, FF for 2's comp
    let positive;
    if (buf[0] === 0x80) positive = true;
    else if (buf[0] === 0xFF) positive = false;
    else return null;
    // build up a base-256 tuple from the least sig to the highest
    const tuple = [];
    let i;
    for(i = buf.length - 1; i > 0; i--){
        const byte = buf[i];
        if (positive) tuple.push(byte);
        else tuple.push(0xFF - byte);
    }
    let sum = 0;
    const l = tuple.length;
    for(i = 0; i < l; i++){
        sum += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum : -1 * sum;
}
function decodeOct(val, offset, length) {
    val = val.subarray(offset, offset + length);
    offset = 0;
    // If prefixed with 0x80 then parse as a base-256 integer
    if (val[offset] & 0x80) {
        return parse256(val);
    } else {
        // Older versions of tar can prefix with spaces
        while(offset < val.length && val[offset] === 32)offset++;
        const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while(offset < end && val[offset] === 0)offset++;
        if (end === offset) return 0;
        return parseInt(b4a.toString(val.subarray(offset, end)), 8);
    }
}
function decodeStr(val, offset, length, encoding) {
    return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
}
function addLength(str) {
    const len = b4a.byteLength(str);
    let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits)) digits++;
    return len + digits + str;
}
}}),
"[project]/node_modules/tar-stream/extract.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const { Writable, Readable, getStreamError } = __turbopack_context__.r("[project]/node_modules/streamx/index.js [app-route] (ecmascript)");
const FIFO = __turbopack_context__.r("[project]/node_modules/fast-fifo/index.js [app-route] (ecmascript)");
const b4a = __turbopack_context__.r("[project]/node_modules/b4a/index.js [app-route] (ecmascript)");
const headers = __turbopack_context__.r("[project]/node_modules/tar-stream/headers.js [app-route] (ecmascript)");
const EMPTY = b4a.alloc(0);
class BufferList {
    constructor(){
        this.buffered = 0;
        this.shifted = 0;
        this.queue = new FIFO();
        this._offset = 0;
    }
    push(buffer) {
        this.buffered += buffer.byteLength;
        this.queue.push(buffer);
    }
    shiftFirst(size) {
        return this._buffered === 0 ? null : this._next(size);
    }
    shift(size) {
        if (size > this.buffered) return null;
        if (size === 0) return EMPTY;
        let chunk = this._next(size);
        if (size === chunk.byteLength) return chunk // likely case
        ;
        const chunks = [
            chunk
        ];
        while((size -= chunk.byteLength) > 0){
            chunk = this._next(size);
            chunks.push(chunk);
        }
        return b4a.concat(chunks);
    }
    _next(size) {
        const buf = this.queue.peek();
        const rem = buf.byteLength - this._offset;
        if (size >= rem) {
            const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
            this.queue.shift();
            this._offset = 0;
            this.buffered -= rem;
            this.shifted += rem;
            return sub;
        }
        this.buffered -= size;
        this.shifted += size;
        return buf.subarray(this._offset, this._offset += size);
    }
}
class Source extends Readable {
    constructor(self, header, offset){
        super();
        this.header = header;
        this.offset = offset;
        this._parent = self;
    }
    _read(cb) {
        if (this.header.size === 0) {
            this.push(null);
        }
        if (this._parent._stream === this) {
            this._parent._update();
        }
        cb(null);
    }
    _predestroy() {
        this._parent.destroy(getStreamError(this));
    }
    _detach() {
        if (this._parent._stream === this) {
            this._parent._stream = null;
            this._parent._missing = overflow(this.header.size);
            this._parent._update();
        }
    }
    _destroy(cb) {
        this._detach();
        cb(null);
    }
}
class Extract extends Writable {
    constructor(opts){
        super(opts);
        if (!opts) opts = {};
        this._buffer = new BufferList();
        this._offset = 0;
        this._header = null;
        this._stream = null;
        this._missing = 0;
        this._longHeader = false;
        this._callback = noop;
        this._locked = false;
        this._finished = false;
        this._pax = null;
        this._paxGlobal = null;
        this._gnuLongPath = null;
        this._gnuLongLinkPath = null;
        this._filenameEncoding = opts.filenameEncoding || 'utf-8';
        this._allowUnknownFormat = !!opts.allowUnknownFormat;
        this._unlockBound = this._unlock.bind(this);
    }
    _unlock(err) {
        this._locked = false;
        if (err) {
            this.destroy(err);
            this._continueWrite(err);
            return;
        }
        this._update();
    }
    _consumeHeader() {
        if (this._locked) return false;
        this._offset = this._buffer.shifted;
        try {
            this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
        } catch (err) {
            this._continueWrite(err);
            return false;
        }
        if (!this._header) return true;
        switch(this._header.type){
            case 'gnu-long-path':
            case 'gnu-long-link-path':
            case 'pax-global-header':
            case 'pax-header':
                this._longHeader = true;
                this._missing = this._header.size;
                return true;
        }
        this._locked = true;
        this._applyLongHeaders();
        if (this._header.size === 0 || this._header.type === 'directory') {
            this.emit('entry', this._header, this._createStream(), this._unlockBound);
            return true;
        }
        this._stream = this._createStream();
        this._missing = this._header.size;
        this.emit('entry', this._header, this._stream, this._unlockBound);
        return true;
    }
    _applyLongHeaders() {
        if (this._gnuLongPath) {
            this._header.name = this._gnuLongPath;
            this._gnuLongPath = null;
        }
        if (this._gnuLongLinkPath) {
            this._header.linkname = this._gnuLongLinkPath;
            this._gnuLongLinkPath = null;
        }
        if (this._pax) {
            if (this._pax.path) this._header.name = this._pax.path;
            if (this._pax.linkpath) this._header.linkname = this._pax.linkpath;
            if (this._pax.size) this._header.size = parseInt(this._pax.size, 10);
            this._header.pax = this._pax;
            this._pax = null;
        }
    }
    _decodeLongHeader(buf) {
        switch(this._header.type){
            case 'gnu-long-path':
                this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding);
                break;
            case 'gnu-long-link-path':
                this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding);
                break;
            case 'pax-global-header':
                this._paxGlobal = headers.decodePax(buf);
                break;
            case 'pax-header':
                this._pax = this._paxGlobal === null ? headers.decodePax(buf) : Object.assign({}, this._paxGlobal, headers.decodePax(buf));
                break;
        }
    }
    _consumeLongHeader() {
        this._longHeader = false;
        this._missing = overflow(this._header.size);
        const buf = this._buffer.shift(this._header.size);
        try {
            this._decodeLongHeader(buf);
        } catch (err) {
            this._continueWrite(err);
            return false;
        }
        return true;
    }
    _consumeStream() {
        const buf = this._buffer.shiftFirst(this._missing);
        if (buf === null) return false;
        this._missing -= buf.byteLength;
        const drained = this._stream.push(buf);
        if (this._missing === 0) {
            this._stream.push(null);
            if (drained) this._stream._detach();
            return drained && this._locked === false;
        }
        return drained;
    }
    _createStream() {
        return new Source(this, this._header, this._offset);
    }
    _update() {
        while(this._buffer.buffered > 0 && !this.destroying){
            if (this._missing > 0) {
                if (this._stream !== null) {
                    if (this._consumeStream() === false) return;
                    continue;
                }
                if (this._longHeader === true) {
                    if (this._missing > this._buffer.buffered) break;
                    if (this._consumeLongHeader() === false) return false;
                    continue;
                }
                const ignore = this._buffer.shiftFirst(this._missing);
                if (ignore !== null) this._missing -= ignore.byteLength;
                continue;
            }
            if (this._buffer.buffered < 512) break;
            if (this._stream !== null || this._consumeHeader() === false) return;
        }
        this._continueWrite(null);
    }
    _continueWrite(err) {
        const cb = this._callback;
        this._callback = noop;
        cb(err);
    }
    _write(data, cb) {
        this._callback = cb;
        this._buffer.push(data);
        this._update();
    }
    _final(cb) {
        this._finished = this._missing === 0 && this._buffer.buffered === 0;
        cb(this._finished ? null : new Error('Unexpected end of data'));
    }
    _predestroy() {
        this._continueWrite(null);
    }
    _destroy(cb) {
        if (this._stream) this._stream.destroy(getStreamError(this));
        cb(null);
    }
    [Symbol.asyncIterator]() {
        let error = null;
        let promiseResolve = null;
        let promiseReject = null;
        let entryStream = null;
        let entryCallback = null;
        const extract = this;
        this.on('entry', onentry);
        this.on('error', (err)=>{
            error = err;
        });
        this.on('close', onclose);
        return {
            [Symbol.asyncIterator] () {
                return this;
            },
            next () {
                return new Promise(onnext);
            },
            return () {
                return destroy(null);
            },
            throw (err) {
                return destroy(err);
            }
        };
        "TURBOPACK unreachable";
        function consumeCallback(err) {
            if (!entryCallback) return;
            const cb = entryCallback;
            entryCallback = null;
            cb(err);
        }
        function onnext(resolve, reject) {
            if (error) {
                return reject(error);
            }
            if (entryStream) {
                resolve({
                    value: entryStream,
                    done: false
                });
                entryStream = null;
                return;
            }
            promiseResolve = resolve;
            promiseReject = reject;
            consumeCallback(null);
            if (extract._finished && promiseResolve) {
                promiseResolve({
                    value: undefined,
                    done: true
                });
                promiseResolve = promiseReject = null;
            }
        }
        function onentry(header, stream, callback) {
            entryCallback = callback;
            stream.on('error', noop) // no way around this due to tick sillyness
            ;
            if (promiseResolve) {
                promiseResolve({
                    value: stream,
                    done: false
                });
                promiseResolve = promiseReject = null;
            } else {
                entryStream = stream;
            }
        }
        function onclose() {
            consumeCallback(error);
            if (!promiseResolve) return;
            if (error) promiseReject(error);
            else promiseResolve({
                value: undefined,
                done: true
            });
            promiseResolve = promiseReject = null;
        }
        function destroy(err) {
            extract.destroy(err);
            consumeCallback(err);
            return new Promise((resolve, reject)=>{
                if (extract.destroyed) return resolve({
                    value: undefined,
                    done: true
                });
                extract.once('close', function() {
                    if (err) reject(err);
                    else resolve({
                        value: undefined,
                        done: true
                    });
                });
            });
        }
    }
}
module.exports = function extract(opts) {
    return new Extract(opts);
};
function noop() {}
function overflow(size) {
    size &= 511;
    return size && 512 - size;
}
}}),
"[project]/node_modules/tar-stream/constants.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const constants = {
    S_IFMT: 61440,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960
};
try {
    module.exports = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)").constants || constants;
} catch  {
    module.exports = constants;
}
}}),
"[project]/node_modules/tar-stream/pack.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const { Readable, Writable, getStreamError } = __turbopack_context__.r("[project]/node_modules/streamx/index.js [app-route] (ecmascript)");
const b4a = __turbopack_context__.r("[project]/node_modules/b4a/index.js [app-route] (ecmascript)");
const constants = __turbopack_context__.r("[project]/node_modules/tar-stream/constants.js [app-route] (ecmascript)");
const headers = __turbopack_context__.r("[project]/node_modules/tar-stream/headers.js [app-route] (ecmascript)");
const DMODE = 0o755;
const FMODE = 0o644;
const END_OF_TAR = b4a.alloc(1024);
class Sink extends Writable {
    constructor(pack, header, callback){
        super({
            mapWritable,
            eagerOpen: true
        });
        this.written = 0;
        this.header = header;
        this._callback = callback;
        this._linkname = null;
        this._isLinkname = header.type === 'symlink' && !header.linkname;
        this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file';
        this._finished = false;
        this._pack = pack;
        this._openCallback = null;
        if (this._pack._stream === null) this._pack._stream = this;
        else this._pack._pending.push(this);
    }
    _open(cb) {
        this._openCallback = cb;
        if (this._pack._stream === this) this._continueOpen();
    }
    _continuePack(err) {
        if (this._callback === null) return;
        const callback = this._callback;
        this._callback = null;
        callback(err);
    }
    _continueOpen() {
        if (this._pack._stream === null) this._pack._stream = this;
        const cb = this._openCallback;
        this._openCallback = null;
        if (cb === null) return;
        if (this._pack.destroying) return cb(new Error('pack stream destroyed'));
        if (this._pack._finalized) return cb(new Error('pack stream is already finalized'));
        this._pack._stream = this;
        if (!this._isLinkname) {
            this._pack._encode(this.header);
        }
        if (this._isVoid) {
            this._finish();
            this._continuePack(null);
        }
        cb(null);
    }
    _write(data, cb) {
        if (this._isLinkname) {
            this._linkname = this._linkname ? b4a.concat([
                this._linkname,
                data
            ]) : data;
            return cb(null);
        }
        if (this._isVoid) {
            if (data.byteLength > 0) {
                return cb(new Error('No body allowed for this entry'));
            }
            return cb();
        }
        this.written += data.byteLength;
        if (this._pack.push(data)) return cb();
        this._pack._drain = cb;
    }
    _finish() {
        if (this._finished) return;
        this._finished = true;
        if (this._isLinkname) {
            this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : '';
            this._pack._encode(this.header);
        }
        overflow(this._pack, this.header.size);
        this._pack._done(this);
    }
    _final(cb) {
        if (this.written !== this.header.size) {
            return cb(new Error('Size mismatch'));
        }
        this._finish();
        cb(null);
    }
    _getError() {
        return getStreamError(this) || new Error('tar entry destroyed');
    }
    _predestroy() {
        this._pack.destroy(this._getError());
    }
    _destroy(cb) {
        this._pack._done(this);
        this._continuePack(this._finished ? null : this._getError());
        cb();
    }
}
class Pack extends Readable {
    constructor(opts){
        super(opts);
        this._drain = noop;
        this._finalized = false;
        this._finalizing = false;
        this._pending = [];
        this._stream = null;
    }
    entry(header, buffer, callback) {
        if (this._finalized || this.destroying) throw new Error('already finalized or destroyed');
        if (typeof buffer === 'function') {
            callback = buffer;
            buffer = null;
        }
        if (!callback) callback = noop;
        if (!header.size || header.type === 'symlink') header.size = 0;
        if (!header.type) header.type = modeToType(header.mode);
        if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE;
        if (!header.uid) header.uid = 0;
        if (!header.gid) header.gid = 0;
        if (!header.mtime) header.mtime = new Date();
        if (typeof buffer === 'string') buffer = b4a.from(buffer);
        const sink = new Sink(this, header, callback);
        if (b4a.isBuffer(buffer)) {
            header.size = buffer.byteLength;
            sink.write(buffer);
            sink.end();
            return sink;
        }
        if (sink._isVoid) {
            return sink;
        }
        return sink;
    }
    finalize() {
        if (this._stream || this._pending.length > 0) {
            this._finalizing = true;
            return;
        }
        if (this._finalized) return;
        this._finalized = true;
        this.push(END_OF_TAR);
        this.push(null);
    }
    _done(stream) {
        if (stream !== this._stream) return;
        this._stream = null;
        if (this._finalizing) this.finalize();
        if (this._pending.length) this._pending.shift()._continueOpen();
    }
    _encode(header) {
        if (!header.pax) {
            const buf = headers.encode(header);
            if (buf) {
                this.push(buf);
                return;
            }
        }
        this._encodePax(header);
    }
    _encodePax(header) {
        const paxHeader = headers.encodePax({
            name: header.name,
            linkname: header.linkname,
            pax: header.pax
        });
        const newHeader = {
            name: 'PaxHeader',
            mode: header.mode,
            uid: header.uid,
            gid: header.gid,
            size: paxHeader.byteLength,
            mtime: header.mtime,
            type: 'pax-header',
            linkname: header.linkname && 'PaxHeader',
            uname: header.uname,
            gname: header.gname,
            devmajor: header.devmajor,
            devminor: header.devminor
        };
        this.push(headers.encode(newHeader));
        this.push(paxHeader);
        overflow(this, paxHeader.byteLength);
        newHeader.size = header.size;
        newHeader.type = header.type;
        this.push(headers.encode(newHeader));
    }
    _doDrain() {
        const drain = this._drain;
        this._drain = noop;
        drain();
    }
    _predestroy() {
        const err = getStreamError(this);
        if (this._stream) this._stream.destroy(err);
        while(this._pending.length){
            const stream = this._pending.shift();
            stream.destroy(err);
            stream._continueOpen();
        }
        this._doDrain();
    }
    _read(cb) {
        this._doDrain();
        cb();
    }
}
module.exports = function pack(opts) {
    return new Pack(opts);
};
function modeToType(mode) {
    switch(mode & constants.S_IFMT){
        case constants.S_IFBLK:
            return 'block-device';
        case constants.S_IFCHR:
            return 'character-device';
        case constants.S_IFDIR:
            return 'directory';
        case constants.S_IFIFO:
            return 'fifo';
        case constants.S_IFLNK:
            return 'symlink';
    }
    return 'file';
}
function noop() {}
function overflow(self, size) {
    size &= 511;
    if (size) self.push(END_OF_TAR.subarray(0, 512 - size));
}
function mapWritable(buf) {
    return b4a.isBuffer(buf) ? buf : b4a.from(buf);
}
}}),
"[project]/node_modules/tar-stream/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
exports.extract = __turbopack_context__.r("[project]/node_modules/tar-stream/extract.js [app-route] (ecmascript)");
exports.pack = __turbopack_context__.r("[project]/node_modules/tar-stream/pack.js [app-route] (ecmascript)");
}}),
"[project]/node_modules/wrappy/wrappy.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy;
function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== 'function') throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
    });
    return wrapper;
    "TURBOPACK unreachable";
    function wrapper() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb = args[args.length - 1];
        if (typeof ret === 'function' && ret !== cb) {
            Object.keys(cb).forEach(function(k) {
                ret[k] = cb[k];
            });
        }
        return ret;
    }
}
}}),
"[project]/node_modules/once/once.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var wrappy = __turbopack_context__.r("[project]/node_modules/wrappy/wrappy.js [app-route] (ecmascript)");
module.exports = wrappy(once);
module.exports.strict = wrappy(onceStrict);
once.proto = once(function() {
    Object.defineProperty(Function.prototype, 'once', {
        value: function() {
            return once(this);
        },
        configurable: true
    });
    Object.defineProperty(Function.prototype, 'onceStrict', {
        value: function() {
            return onceStrict(this);
        },
        configurable: true
    });
});
function once(fn) {
    var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
}
function onceStrict(fn) {
    var f = function() {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
}
}}),
"[project]/node_modules/end-of-stream/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var once = __turbopack_context__.r("[project]/node_modules/once/once.js [app-route] (ecmascript)");
var noop = function() {};
var qnt = global.Bare ? queueMicrotask : process.nextTick.bind(process);
var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
};
var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};
var eos = function(stream, opts, callback) {
    if (typeof opts === 'function') return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
        if (!stream.writable) onfinish();
    };
    var onfinish = function() {
        writable = false;
        if (!readable) callback.call(stream);
    };
    var onend = function() {
        readable = false;
        if (!writable) callback.call(stream);
    };
    var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
    };
    var onerror = function(err) {
        callback.call(stream, err);
    };
    var onclose = function() {
        qnt(onclosenexttick);
    };
    var onclosenexttick = function() {
        if (cancelled) return;
        if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
        if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
    };
    var onrequest = function() {
        stream.req.on('finish', onfinish);
    };
    if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();
        else stream.on('request', onrequest);
    } else if (writable && !ws) {
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
    }
    if (isChildProcess(stream)) stream.on('exit', onexit);
    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function() {
        cancelled = true;
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('exit', onexit);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
    };
};
module.exports = eos;
}}),
"[project]/node_modules/pump/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var once = __turbopack_context__.r("[project]/node_modules/once/once.js [app-route] (ecmascript)");
var eos = __turbopack_context__.r("[project]/node_modules/end-of-stream/index.js [app-route] (ecmascript)");
var fs;
try {
    fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)") // we only need fs to get the ReadStream and WriteStream prototypes
    ;
} catch (e) {}
var noop = function() {};
var ancient = typeof process === 'undefined' ? false : /^v?\.0/.test(process.version);
var isFn = function(fn) {
    return typeof fn === 'function';
};
var isFS = function(stream) {
    if (!ancient) return false // newer node version do not need to care about fs is a special way
    ;
    if (!fs) return false // browser
    ;
    return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
};
var isRequest = function(stream) {
    return stream.setHeader && isFn(stream.abort);
};
var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function() {
        closed = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
        ;
        if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want
        ;
        if (isFn(stream.destroy)) return stream.destroy();
        callback(err || new Error('stream was destroyed'));
    };
};
var call = function(fn) {
    fn();
};
var pipe = function(from, to) {
    return from.pipe(to);
};
var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new Error('pump requires two streams per minimum');
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
};
module.exports = pump;
}}),
"[project]/node_modules/tar-fs/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const tar = __turbopack_context__.r("[project]/node_modules/tar-stream/index.js [app-route] (ecmascript)");
const pump = __turbopack_context__.r("[project]/node_modules/pump/index.js [app-route] (ecmascript)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const win32 = (global.Bare ? global.Bare.platform : process.platform) === 'win32';
exports.pack = function pack(cwd, opts) {
    if (!cwd) cwd = '.';
    if (!opts) opts = {};
    const xfs = opts.fs || fs;
    const ignore = opts.ignore || opts.filter || noop;
    const mapStream = opts.mapStream || echo;
    const statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);
    const strict = opts.strict !== false;
    const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();
    const pack = opts.pack || tar.pack();
    const finish = opts.finish || noop;
    let map = opts.map || noop;
    let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;
    let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;
    if (opts.strip) map = strip(map, opts.strip);
    if (opts.readable) {
        dmode |= parseInt(555, 8);
        fmode |= parseInt(444, 8);
    }
    if (opts.writable) {
        dmode |= parseInt(333, 8);
        fmode |= parseInt(222, 8);
    }
    onnextentry();
    function onsymlink(filename, header) {
        xfs.readlink(path.join(cwd, filename), function(err, linkname) {
            if (err) return pack.destroy(err);
            header.linkname = normalize(linkname);
            pack.entry(header, onnextentry);
        });
    }
    function onstat(err, filename, stat) {
        if (pack.destroyed) return;
        if (err) return pack.destroy(err);
        if (!filename) {
            if (opts.finalize !== false) pack.finalize();
            return finish(pack);
        }
        if (stat.isSocket()) return onnextentry() // tar does not support sockets...
        ;
        let header = {
            name: normalize(filename),
            mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,
            mtime: stat.mtime,
            size: stat.size,
            type: 'file',
            uid: stat.uid,
            gid: stat.gid
        };
        if (stat.isDirectory()) {
            header.size = 0;
            header.type = 'directory';
            header = map(header) || header;
            return pack.entry(header, onnextentry);
        }
        if (stat.isSymbolicLink()) {
            header.size = 0;
            header.type = 'symlink';
            header = map(header) || header;
            return onsymlink(filename, header);
        }
        // TODO: add fifo etc...
        header = map(header) || header;
        if (!stat.isFile()) {
            if (strict) return pack.destroy(new Error('unsupported type for ' + filename));
            return onnextentry();
        }
        const entry = pack.entry(header, onnextentry);
        const rs = mapStream(xfs.createReadStream(path.join(cwd, filename), {
            start: 0,
            end: header.size > 0 ? header.size - 1 : header.size
        }), header);
        rs.on('error', function(err) {
            entry.destroy(err);
        });
        pump(rs, entry);
    }
    function onnextentry(err) {
        if (err) return pack.destroy(err);
        statNext(onstat);
    }
    return pack;
};
function head(list) {
    return list.length ? list[list.length - 1] : null;
}
function processGetuid() {
    return !global.Bare && process.getuid ? process.getuid() : -1;
}
function processUmask() {
    return !global.Bare && process.umask ? process.umask() : 0;
}
exports.extract = function extract(cwd, opts) {
    if (!cwd) cwd = '.';
    if (!opts) opts = {};
    cwd = path.resolve(cwd);
    const xfs = opts.fs || fs;
    const ignore = opts.ignore || opts.filter || noop;
    const mapStream = opts.mapStream || echo;
    const own = opts.chown !== false && !win32 && processGetuid() === 0;
    const extract = opts.extract || tar.extract();
    const stack = [];
    const now = new Date();
    const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();
    const strict = opts.strict !== false;
    const validateSymLinks = opts.validateSymlinks !== false;
    let map = opts.map || noop;
    let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;
    let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;
    if (opts.strip) map = strip(map, opts.strip);
    if (opts.readable) {
        dmode |= parseInt(555, 8);
        fmode |= parseInt(444, 8);
    }
    if (opts.writable) {
        dmode |= parseInt(333, 8);
        fmode |= parseInt(222, 8);
    }
    extract.on('entry', onentry);
    if (opts.finish) extract.on('finish', opts.finish);
    return extract;
    "TURBOPACK unreachable";
    function onentry(header, stream, next) {
        header = map(header) || header;
        header.name = normalize(header.name);
        const name = path.join(cwd, path.join('/', header.name));
        if (ignore(name, header)) {
            stream.resume();
            return next();
        }
        const dir = path.join(name, '.') === path.join(cwd, '.') ? cwd : path.dirname(name);
        validate(xfs, dir, path.join(cwd, '.'), function(err, valid) {
            if (err) return next(err);
            if (!valid) return next(new Error(dir + ' is not a valid path'));
            if (header.type === 'directory') {
                stack.push([
                    name,
                    header.mtime
                ]);
                return mkdirfix(name, {
                    fs: xfs,
                    own,
                    uid: header.uid,
                    gid: header.gid,
                    mode: header.mode
                }, stat);
            }
            mkdirfix(dir, {
                fs: xfs,
                own,
                uid: header.uid,
                gid: header.gid,
                // normally, the folders with rights and owner should be part of the TAR file
                // if this is not the case, create folder for same user as file and with
                // standard permissions of 0o755 (rwxr-xr-x)
                mode: 0o755
            }, function(err) {
                if (err) return next(err);
                switch(header.type){
                    case 'file':
                        return onfile();
                    case 'link':
                        return onlink();
                    case 'symlink':
                        return onsymlink();
                }
                if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'));
                stream.resume();
                next();
            });
        });
        function stat(err) {
            if (err) return next(err);
            utimes(name, header, function(err) {
                if (err) return next(err);
                if (win32) return next();
                chperm(name, header, next);
            });
        }
        function onsymlink() {
            if (win32) return next() // skip symlinks on win for now before it can be tested
            ;
            xfs.unlink(name, function() {
                const dst = path.resolve(path.dirname(name), header.linkname);
                if (!inCwd(dst) && validateSymLinks) return next(new Error(name + ' is not a valid symlink'));
                xfs.symlink(header.linkname, name, stat);
            });
        }
        function onlink() {
            if (win32) return next() // skip links on win for now before it can be tested
            ;
            xfs.unlink(name, function() {
                const link = path.join(cwd, path.join('/', header.linkname));
                fs.realpath(link, function(err, dst) {
                    if (err || !inCwd(dst)) return next(new Error(name + ' is not a valid hardlink'));
                    xfs.link(dst, name, function(err) {
                        if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {
                            stream = xfs.createReadStream(dst);
                            return onfile();
                        }
                        stat(err);
                    });
                });
            });
        }
        function inCwd(dst) {
            return dst.startsWith(cwd);
        }
        function onfile() {
            const ws = xfs.createWriteStream(name);
            const rs = mapStream(stream, header);
            ws.on('error', function(err) {
                rs.destroy(err);
            });
            pump(rs, ws, function(err) {
                if (err) return next(err);
                ws.on('close', stat);
            });
        }
    }
    function utimesParent(name, cb) {
        let top;
        while((top = head(stack)) && name.slice(0, top[0].length) !== top[0])stack.pop();
        if (!top) return cb();
        xfs.utimes(top[0], now, top[1], cb);
    }
    function utimes(name, header, cb) {
        if (opts.utimes === false) return cb();
        if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb);
        if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?
        ;
        xfs.utimes(name, now, header.mtime, function(err) {
            if (err) return cb(err);
            utimesParent(name, cb);
        });
    }
    function chperm(name, header, cb) {
        const link = header.type === 'symlink';
        /* eslint-disable n/no-deprecated-api */ const chmod = link ? xfs.lchmod : xfs.chmod;
        const chown = link ? xfs.lchown : xfs.chown;
        /* eslint-enable n/no-deprecated-api */ if (!chmod) return cb();
        const mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask;
        if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown);
        else onchown(null);
        function onchown(err) {
            if (err) return cb(err);
            if (!chmod) return cb();
            chmod.call(xfs, name, mode, cb);
        }
    }
    function mkdirfix(name, opts, cb) {
        // when mkdir is called on an existing directory, the permissions
        // will be overwritten (?), to avoid this we check for its existance first
        xfs.stat(name, function(err) {
            if (!err) return cb(null);
            if (err.code !== 'ENOENT') return cb(err);
            xfs.mkdir(name, {
                mode: opts.mode,
                recursive: true
            }, function(err, made) {
                if (err) return cb(err);
                chperm(name, opts, cb);
            });
        });
    }
};
function validate(fs, name, root, cb) {
    if (name === root) return cb(null, true);
    fs.lstat(name, function(err, st) {
        if (err && err.code !== 'ENOENT' && err.code !== 'EPERM') return cb(err);
        if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb);
        cb(null, false);
    });
}
function noop() {}
function echo(name) {
    return name;
}
function normalize(name) {
    return win32 ? name.replace(/\\/g, '/').replace(/[:?<>|]/g, '_') : name;
}
function statAll(fs, stat, cwd, ignore, entries, sort) {
    if (!entries) entries = [
        '.'
    ];
    const queue = entries.slice(0);
    return function loop(callback) {
        if (!queue.length) return callback(null);
        const next = queue.shift();
        const nextAbs = path.join(cwd, next);
        stat.call(fs, nextAbs, function(err, stat) {
            // ignore errors if the files were deleted while buffering
            if (err) return callback(entries.indexOf(next) === -1 && err.code === 'ENOENT' ? null : err);
            if (!stat.isDirectory()) return callback(null, next, stat);
            fs.readdir(nextAbs, function(err, files) {
                if (err) return callback(err);
                if (sort) files.sort();
                for(let i = 0; i < files.length; i++){
                    if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]));
                }
                callback(null, next, stat);
            });
        });
    };
}
function strip(map, level) {
    return function(header) {
        header.name = header.name.split('/').slice(level).join('/');
        const linkname = header.linkname;
        if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {
            header.linkname = linkname.split('/').slice(level).join('/');
        }
        return map(header);
    };
}
}}),
"[project]/node_modules/@sparticuz/chromium-min/build/esm/helper.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSymlink": (()=>createSymlink),
    "downloadAndExtract": (()=>downloadAndExtract),
    "downloadFile": (()=>downloadFile),
    "isRunningInAmazonLinux2023": (()=>isRunningInAmazonLinux2023),
    "isValidUrl": (()=>isValidUrl),
    "setupLambdaEnvironment": (()=>setupLambdaEnvironment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$follow$2d$redirects$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/follow-redirects/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tar$2d$fs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tar-fs/index.js [app-route] (ecmascript)");
;
;
;
;
;
const createSymlink = (source, target)=>{
    return new Promise((resolve, reject)=>{
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["access"])(source, (error)=>{
            if (error) {
                reject(error);
                return;
            }
            (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["symlink"])(source, target, (error)=>{
                /* c8 ignore next */ if (error) {
                    /* c8 ignore next 3 */ reject(error);
                    return;
                }
                resolve();
            });
        });
    });
};
const downloadFile = (url, outputPath)=>{
    return new Promise((resolve, reject)=>{
        const stream = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["createWriteStream"])(outputPath);
        stream.once("error", reject);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$follow$2d$redirects$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].https.get(url, (response)=>{
            if (response.statusCode !== 200) {
                stream.close();
                reject(new Error(/* c8 ignore next 2 */ `Unexpected status code: ${response.statusCode?.toFixed(0) ?? "UNK"}.`));
                return;
            }
            // Pipe directly to file rather than manually writing chunks
            // This is more efficient and uses less memory
            response.pipe(stream);
            // Listen for completion
            stream.once("finish", ()=>{
                stream.close();
                resolve();
            });
            // Handle response errors
            response.once("error", (error)=>{
                /* c8 ignore next 2 */ stream.close();
                reject(error);
            });
        })/* c8 ignore next 3 */ .on("error", (error)=>{
            stream.close();
            reject(error);
        });
    });
};
const setupLambdaEnvironment = (baseLibPath)=>{
    // If the FONTCONFIG_PATH is not set, set it to /tmp/fonts
    process.env["FONTCONFIG_PATH"] ??= (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])(), "fonts");
    // Set up Home folder if not already set
    process.env["HOME"] ??= (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])();
    // If LD_LIBRARY_PATH is undefined, set it to baseLibPath, otherwise, add it
    if (process.env["LD_LIBRARY_PATH"] === undefined) {
        process.env["LD_LIBRARY_PATH"] = baseLibPath;
    } else if (!process.env["LD_LIBRARY_PATH"].startsWith(baseLibPath)) {
        process.env["LD_LIBRARY_PATH"] = [
            baseLibPath,
            ...new Set(process.env["LD_LIBRARY_PATH"].split(":"))
        ].join(":");
    }
};
const isValidUrl = (input)=>{
    try {
        return Boolean(new URL(input));
    } catch  {
        return false;
    }
};
const isRunningInAmazonLinux2023 = (nodeMajorVersion)=>{
    const awsExecEnv = process.env["AWS_EXECUTION_ENV"] ?? "";
    const awsLambdaJsRuntime = process.env["AWS_LAMBDA_JS_RUNTIME"] ?? "";
    const codebuildImage = process.env["CODEBUILD_BUILD_IMAGE"] ?? "";
    // Check for explicit version substrings, returns on first match
    if (awsExecEnv.includes("20.x") || awsExecEnv.includes("22.x") || awsLambdaJsRuntime.includes("20.x") || awsLambdaJsRuntime.includes("22.x") || codebuildImage.includes("nodejs20") || codebuildImage.includes("nodejs22")) {
        return true;
    }
    // Vercel: Node 20+ is AL2023 compatible
    // eslint-disable-next-line sonarjs/prefer-single-boolean-return
    if (process.env["VERCEL"] && nodeMajorVersion >= 20) {
        return true;
    }
    return false;
};
const downloadAndExtract = async (url)=>{
    const getOptions = new URL(url);
    // Increase the max body length to 60MB for larger files
    getOptions.maxBodyLength = 60 * 1024 * 1024;
    const destDir = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])(), "chromium-pack");
    return new Promise((resolve, reject)=>{
        const extractObj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tar$2d$fs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extract"])(destDir);
        // Setup error handlers for better cleanup
        /* c8 ignore next 5 */ const cleanupOnError = (err)=>{
            (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["rm"])(destDir, {
                force: true,
                recursive: true
            }, ()=>{
                reject(err);
            });
        };
        // Attach error handler to extract stream
        extractObj.once("error", cleanupOnError);
        // Handle extraction completion
        extractObj.once("finish", ()=>{
            resolve(destDir);
        });
        const req = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$follow$2d$redirects$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].https.get(url, (response)=>{
            /* c8 ignore next */ if (response.statusCode !== 200) {
                /* c8 ignore next 9 */ reject(new Error(`Unexpected status code: ${response.statusCode?.toFixed(0) ?? "UNK"}.`));
                return;
            }
            // Pipe the response directly to the extraction stream
            response.pipe(extractObj);
            // Handle response errors
            response.once("error", cleanupOnError);
        });
        // Handle request errors
        req.once("error", cleanupOnError);
        // Set a timeout to avoid hanging requests
        req.setTimeout(60 * 1000, ()=>{
            /* c8 ignore next 2 */ req.destroy();
            cleanupOnError(new Error("Request timeout"));
        });
    });
};
}}),
"[project]/node_modules/@sparticuz/chromium-min/build/esm/lambdafs.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "inflate": (()=>inflate)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$zlib__$5b$external$5d$__$28$node$3a$zlib$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:zlib [external] (node:zlib, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tar$2d$fs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tar-fs/index.js [app-route] (ecmascript)");
;
;
;
;
;
const inflate = (filePath)=>{
    // Determine the output path based on the file type
    const output = filePath.includes("swiftshader") ? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])() : (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])(), (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["basename"])(filePath).replace(/\.(?:t(?:ar(?:\.(?:br|gz))?|br|gz)|br|gz)$/i, ""));
    return new Promise((resolve, reject)=>{
        // Quick return if the file is already decompressed
        if (filePath.includes("swiftshader")) {
            if ((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["existsSync"])(`${output}/libGLESv2.so`)) {
                resolve(output);
                return;
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["existsSync"])(output)) {
            resolve(output);
            return;
        }
        // Optimize chunk size based on file type - use smaller chunks for better memory usage
        // Brotli files tend to decompress to much larger sizes
        const isBrotli = /br$/i.test(filePath);
        const isGzip = /gz$/i.test(filePath);
        const isTar = /\.t(?:ar(?:\.(?:br|gz))?|br|gz)$/i.test(filePath);
        // Use a smaller highWaterMark for better memory efficiency
        // For most serverless environments, 4MB (2**22) is more memory-efficient than 8MB
        const highWaterMark = 2 ** 22;
        const source = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["createReadStream"])(filePath, {
            highWaterMark
        });
        let target;
        // Setup error handlers first for both streams
        const handleError = (error)=>{
            reject(error);
        };
        source.once("error", handleError);
        // Setup the appropriate target stream based on file type
        if (isTar) {
            target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tar$2d$fs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extract"])(output);
            target.once("finish", ()=>{
                resolve(output);
            });
        } else {
            target = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["createWriteStream"])(output, {
                mode: 0o700
            });
            target.once("close", ()=>{
                resolve(output);
            });
        }
        target.once("error", handleError);
        // Pipe through the appropriate decompressor if needed
        if (isBrotli || isGzip) {
            // Use optimized chunk size for decompression
            // 2MB (2**21) is sufficient for most brotli/gzip files
            const decompressor = isBrotli ? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$zlib__$5b$external$5d$__$28$node$3a$zlib$2c$__cjs$29$__["createBrotliDecompress"])({
                chunkSize: 2 ** 21
            }) : (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$zlib__$5b$external$5d$__$28$node$3a$zlib$2c$__cjs$29$__["createUnzip"])({
                chunkSize: 2 ** 21
            });
            // Handle decompressor errors
            decompressor.once("error", handleError);
            // Chain the streams
            source.pipe(decompressor).pipe(target);
        } else {
            source.pipe(target);
        }
    });
};
}}),
"[project]/node_modules/@sparticuz/chromium-min/build/esm/paths.esm.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getBinPath": (()=>getBinPath)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@sparticuz/chromium-min/build/esm/paths.esm.js")}`;
    }
};
;
;
function getBinPath() {
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["dirname"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(__TURBOPACK__import$2e$meta__.url)), "..", "..", "bin");
}
}}),
"[project]/node_modules/@sparticuz/chromium-min/build/esm/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sparticuz/chromium-min/build/esm/helper.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$lambdafs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sparticuz/chromium-min/build/esm/lambdafs.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$paths$2e$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sparticuz/chromium-min/build/esm/paths.esm.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
const nodeMajorVersion = Number.parseInt(process.versions.node.split(".")[0] ?? "");
// Setup the lambda environment
if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRunningInAmazonLinux2023"])(nodeMajorVersion)) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setupLambdaEnvironment"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])(), "al2023", "lib"));
}
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class Chromium {
    /**
     * Returns a list of additional Chromium flags recommended for serverless environments.
     * The canonical list of flags can be found on https://peter.sh/experiments/chromium-command-line-switches/.
     * Most of below can be found here: https://github.com/GoogleChrome/chrome-launcher/blob/main/docs/chrome-flags-for-tools.md
     */ static get args() {
        const chromiumFlags = [
            "--ash-no-nudges",
            "--disable-domain-reliability",
            "--disable-print-preview",
            "--disk-cache-size=33554432",
            "--no-default-browser-check",
            "--no-pings",
            "--single-process",
            "--font-render-hinting=none"
        ];
        const chromiumDisableFeatures = [
            "AudioServiceOutOfProcess",
            "IsolateOrigins",
            "site-per-process"
        ];
        const chromiumEnableFeatures = [
            "SharedArrayBuffer"
        ];
        const graphicsFlags = [
            "--ignore-gpu-blocklist",
            "--in-process-gpu"
        ];
        // https://chromium.googlesource.com/chromium/src/+/main/docs/gpu/swiftshader.md
        if (this.graphics) {
            graphicsFlags.push(// As the unsafe WebGL fallback, SwANGLE (ANGLE + SwiftShader Vulkan)
            "--use-gl=angle", "--use-angle=swiftshader", "--enable-unsafe-swiftshader");
        } else {
            graphicsFlags.push("--disable-webgl");
        }
        const insecureFlags = [
            "--allow-running-insecure-content",
            "--disable-setuid-sandbox",
            "--disable-site-isolation-trials",
            "--disable-web-security"
        ];
        const headlessFlags = [
            "--headless='shell'",
            "--no-sandbox",
            "--no-zygote"
        ];
        return [
            ...chromiumFlags,
            `--disable-features=${[
                ...chromiumDisableFeatures
            ].join(",")}`,
            `--enable-features=${[
                ...chromiumEnableFeatures
            ].join(",")}`,
            ...graphicsFlags,
            ...insecureFlags,
            ...headlessFlags
        ];
    }
    /**
     * Returns whether the graphics stack is enabled or disabled
     * @returns boolean
     */ static get graphics() {
        return this.graphicsMode;
    }
    /**
     * Sets whether the graphics stack is enabled or disabled.
     * @param true means the stack is enabled. WebGL will work.
     * @param false means that the stack is disabled. WebGL will not work.
     * @default true
     */ static set setGraphicsMode(value) {
        if (typeof value !== "boolean") {
            throw new TypeError(`Graphics mode must be a boolean, you entered '${String(value)}'`);
        }
        this.graphicsMode = value;
    }
    /**
     * If true, the graphics stack and webgl is enabled,
     * If false, webgl will be disabled.
     * (If false, the swiftshader.tar.br file will also not extract)
     */ static graphicsMode = true;
    /**
     * Inflates the included version of Chromium
     * @param input The location of the `bin` folder
     * @returns The path to the `chromium` binary
     */ static async executablePath(input) {
        /**
         * If the `chromium` binary already exists in /tmp/chromium, return it.
         */ if ((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["existsSync"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])(), "chromium"))) {
            return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])(), "chromium");
        }
        /**
         * If input is a valid URL, download and extract the file. It will extract to /tmp/chromium-pack
         * and executablePath will be recursively called on that location, which will then extract
         * the brotli files to the correct locations
         */ if (input && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isValidUrl"])(input)) {
            return this.executablePath(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["downloadAndExtract"])(input));
        }
        /**
         * If input is defined, use that as the location of the brotli files,
         * otherwise, the default location is ../../bin.
         * A custom location is needed for workflows that using custom packaging.
         */ input ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$paths$2e$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBinPath"])();
        /**
         * If the input directory doesn't exist, throw an error.
         */ if (!(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["existsSync"])(input)) {
            throw new Error(`The input directory "${input}" does not exist. Please provide the location of the brotli files.`);
        }
        // Extract the required files
        const promises = [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$lambdafs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inflate"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(input, "chromium.br")),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$lambdafs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inflate"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(input, "fonts.tar.br")),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$lambdafs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inflate"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(input, "swiftshader.tar.br"))
        ];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRunningInAmazonLinux2023"])(nodeMajorVersion)) {
            promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$lambdafs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inflate"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(input, "al2023.tar.br")));
        }
        // Await all extractions
        const result = await Promise.all(promises);
        // Returns the first result of the promise, which is the location of the `chromium` binary
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return result.shift();
    }
    /**
     * Downloads or symlinks a custom font and returns its basename, patching the environment so that Chromium can find it.
     */ static async font(input) {
        const fontsDir = process.env["FONTCONFIG_PATH"] ?? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(process.env["HOME"] ?? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["tmpdir"])(), ".fonts");
        // Create fonts directory if it doesn't exist
        if (!(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["existsSync"])(fontsDir)) {
            (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["mkdirSync"])(fontsDir);
        }
        // Convert local path to file URL if needed
        if (!/^https?:\/\//i.test(input)) {
            input = `file://${input}`;
        }
        const url = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](input);
        const fontName = url.pathname.split("/").pop();
        if (!fontName) {
            throw new Error(`Invalid font name: ${url.pathname}`);
        }
        const outputPath = `${fontsDir}/${fontName}`;
        // Return font name if it already exists
        if ((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["existsSync"])(outputPath)) {
            return fontName;
        }
        // Handle local file
        if (url.protocol === "file:") {
            try {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSymlink"])(url.pathname, outputPath);
                return fontName;
            } catch (error) {
                throw new Error(`Failed to create symlink for font: ${JSON.stringify(error)}`);
            }
        } else {
            try {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sparticuz$2f$chromium$2d$min$2f$build$2f$esm$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["downloadFile"])(input, outputPath);
                return fontName;
            } catch (error) {
                throw new Error(`Failed to download font: ${JSON.stringify(error)}`);
            }
        }
    }
}
const __TURBOPACK__default__export__ = Chromium;
}}),

};

//# sourceMappingURL=node_modules_160c350c._.js.map